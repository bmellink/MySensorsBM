/**
 * The MySensors Arduino library handles the wireless radio link and protocol
 * between your home built sensors/actuators and HA controller of choice.
 * The sensors forms a self healing radio network with optional repeaters. Each
 * repeater and gateway builds a routing tables in EEPROM which keeps track of the
 * network topology allowing messages to be routed to nodes.
 *
 * Created by Henrik Ekblad <henrik.ekblad@mysensors.org>
 * Copyright (C) 2013-2015 Sensnology AB
 * Full contributor list: https://github.com/mysensors/Arduino/graphs/contributors
 *
 * Documentation: http://www.mysensors.org
 * Support Forum: http://forum.mysensors.org
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * Note: using timer0 to generate a second interrupt for our 1 ms counters. timer0 is still also  used for delay()
 *
 * Functions BASEMENT HUB
 * - Temperature (with Dallas temp) kamer Mark
 * - Light sensor kamer Mark (LDR)
 * - Temperature + Humidity sensor pump area
 * - Temperature + Humidity sensor bath room
 * - Light sensor bath room
 * - Water leak sensor pump area
 * - LED status lights pump (2x)
 * - Microphone noise sensor pump --> use fourier funcion lib FHT to understand what happens
 * - Temperature shower water
 * - Current (power) usage pump
 * - 1 relais to force on ventilator 
 * - 2 relais to override basement thermostat (auto/manual and manual on/off)
 * 
 * Note: requires patch of core serial library. See http://www.hobbytronics.co.uk/arduino-serial-buffer-size
 * - Make copy of lib file at C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino to C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino16
 * - Modify HardwareSerial.h and add in the beginning: #define SERIAL_TX_BUFFER_SIZE 16 and #define SERIAL_RX_BUFFER_SIZE 16
 * - Modify C:\Program Files (x86)\Arduino\hardware\arduino\avr\boards.txt and copy pro section to pro2 section (new board name) with pro2.build.core=arduino16
 * 
 *  Show the symbol table after compiling:
 *  "C:\Program Files (x86)\Arduino\hardware\tools\avr\bin\avr-nm" -Crtd --size-sort \users\bmellink\AppData\Local\Temp\arduino_build_651097\BasementHub.ino.elf
 *******************************  */


// BOARD: PRO MINI 5V V/ 16Mhz ATMEGA328 8Mhz

// Enable debug prints to serial monitor
#define MY_DEBUG 1

// Enable and select radio type attached
#define MY_RADIO_NRF24
#define MY_REPEATER_FEATURE       // repeater

// node ID's
#define MY_NODE_ID 20             // start naming my own nodes at number 10

#define SHOWER_TEMP_ID 0          // Showed DHT 22 (hygro + temp)
#define SHOWER_HUM_ID 1           // Showed DHT 22 (hygro + temp)
#define PUMP_TEMP_ID 2            // Pump room DHT 22 (hygro + temp)
#define PUMP_HUM_ID 3             // Pump room DHT 22 (hygro + temp)
#define ROOM_TEMP_ID 4            // Room temperature
//#define ROOM_HUM_ID 4           // Room humidity (dummy)
#define WATER_TEMP_ID 5           // Shower water temperature
//#define WATER_HUM_ID 5          // Shower water humidity (dummy)
#define SHOWER_LIGHT_ID 6         // Shower light level
#define ROOM_LIGHT_ID 7           // Room light level
#define PUMP_STATUS_ID 8          // Pump status (0=normal, 1=faulty detection, 2=blocked, 3=general alarm, 4=power off, 5=pump on too long)
#define PUMP_BITS_ID 9            // Individual status bits. Bit numbers: (0=PowerLED, 1=ErrLED, 2=Pumprun current, 3=Sound)
#define PUMP_RUN_ID 10            // Pump running
#define LEAK_ID 11                // Leaking water
#define RELAIS1_ID 12             // Relais thermostat auto/manual (high=manual)
#define RELAIS2_ID 13             // Relais thermostat manual on/off (high=on)
#define RELAIS3_ID 14             // Relais ventillator overrule (high=manual)
#define PING_ID 15                // ID of ping counter

#include <SPI.h>
#include <MySensors.h>  
#include <DallasTemperature.h>
#include <OneWire.h>
#include <DHT.h>

// Fourier analysis functions
#define LOG_OUT 1 // use the log output function
#define FHT_N 128 // set to 128 data point sample fht, resulting in 64 data buckets
#include <FHT.h> // include the library

// PIN connections
#define SHOWER_DHT_PIN 7          // Showed DHT 22 (hygro + temp)
#define PUMP_DHT_PIN 8            // Pump room DHT 22 (hygro + temp)
#define TEMP_PIN 3                // Temp sensors pin (Dallas) - Shower water + Room
#define SHOWER_LDR_PIN A0         // Shower Light LDR (lower voltage is more light)
#define ROOM_LDR_PIN A1           // Room Light LDR (lower voltage is more light)
#define PUMP_ERR_LDR_PIN A2       // Pump Error LED LDR (lower voltage, Error LED is on)
#define PUMP_PWR_LRD_PIN A3       // Pump Power LED LDR (lower voltage, Power LED is on)
#define PUMP_MIC_PIN A7           // Pump Microphone signal
#define LEAK_PIN A6               // Leak sensor floor (<4 V then water on floor)
#define PUMP_CURRENT_PIN A5       // Current measurement pump
#define RELAIS1_PIN 4             // Relais thermostat auto/manual (high=manual)
#define RELAIS2_PIN 5             // Relais thermostat manual on/off (high=on)
#define RELAIS3_PIN 6             // Relais ventillator overrule (high=manual)

// delay times
#define CHECK_FREQUENCY 100       // time in milliseconds between loop (where we check the sensor) - 100ms - 0.1 sec
#define MIN_SEND_FREQ 150         // Minimum time between send (in multiplies of CHECK_FREQUENCY). We don't want to spam the gateway (15 seconds)
#define MIN_SEND_FREQ_ERR 100     // Minimum time between sending our last data again in case of comm error (multiplied by CHECK_FREQUENCY) - 10 sec
#define MAX_SEND_FREQ 3000        // Maximum time between send (in multiplies of CHECK_FREQUENCY). We need to show we are alive (300 sec/5 min)
#define MIN_PINGSEND_FREQ 600     // Time between pings (60 secs)

// one wire config
#define ONE_WIRE_BUS TEMP_PIN
#define MAX_ATTACHED_DS18B20 16

// configs
#define MAXERRCNT 20                // max error count before we do reboot
#define SHOWER_SENSOR_TEMP_OFFSET 0 // offset sensors shower temp
#define WATER_SENSOR_TEMP_OFFSET 0  // offset sensors shower temp
#define ROOM_SENSOR_TEMP_OFFSET 0   // offset sensors shower temp
#define PUMP_SENSOR_TEMP_OFFSET 0   // offset sensors shower temp


// Motion message types - Please note each message requires 51 byte RAM storage
MyMessage showerTemp_msg(SHOWER_TEMP_ID, V_TEMP); 
MyMessage showerHum_msg(SHOWER_HUM_ID, V_HUM);
MyMessage pumpTemp_msg(PUMP_TEMP_ID, V_TEMP); 
MyMessage pumpHum_msg(PUMP_HUM_ID, V_HUM);
MyMessage roomTemp_msg(ROOM_TEMP_ID, V_TEMP); 
MyMessage waterTemp_msg(WATER_TEMP_ID, V_TEMP); 
//MyMessage roomHum_msg(ROOM_HUM_ID, V_HUM); 
//MyMessage waterHum_msg(WATER_HUM_ID, V_HUM); 

MyMessage showerLight_msg(SHOWER_LIGHT_ID, V_LIGHT_LEVEL);
MyMessage roomLight_msg(ROOM_LIGHT_ID, V_LIGHT_LEVEL);
MyMessage pumpStatus_msg(PUMP_STATUS_ID,V_DISTANCE);
MyMessage pumpBits_msg(PUMP_BITS_ID,V_DISTANCE);
MyMessage leak_msg(LEAK_ID, V_TRIPPED);
MyMessage ping_msg(PING_ID,V_DISTANCE);
MyMessage relais1_msg(RELAIS1_ID,V_STATUS);
MyMessage relais2_msg(RELAIS2_ID,V_STATUS);
MyMessage relais3_msg(RELAIS3_ID,V_STATUS);


OneWire oneWire(ONE_WIRE_BUS); // Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
DallasTemperature sensors(&oneWire); // Pass the oneWire reference to Dallas Temperature. 

//#define DHTTYPE DHT11   // DHT 11
#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321
//#define DHTTYPE DHT21   // DHT 21 (AM2301)
DHT showerdht(SHOWER_DHT_PIN, DHTTYPE);
DHT pumpdht(PUMP_DHT_PIN, DHTTYPE);


bool metric = true;
unsigned int numSensors = 0;

unsigned int minsendcnt = MIN_SEND_FREQ;  // counter for keeping minimum intervals between sending 
unsigned int maxsendcnt = MAX_SEND_FREQ;  // counter for keeping maximum intervals between sending 
unsigned int tempsendcnt = MIN_SEND_FREQ;  
unsigned int tempsendcntmax = MAX_SEND_FREQ;
unsigned int lightcnt = MIN_SEND_FREQ;
unsigned int dhtcnt = MIN_SEND_FREQ;
unsigned int pingsendcnt = MIN_PINGSEND_FREQ;

unsigned long pingcnt = 0;                // ping counter (increments at each temperature emasurement, reset at reboot)
unsigned int errcnt = 0;                  // send message error counter
bool initdone = false;                    // not yet init fully completed

void(* resetFunc) (void) = 0;//declare reset function at address 0

// sensor value intermediate storage
unsigned int lastRoomlight = 0;     // save value for room light
unsigned int lastShowerlight = 0;   // save value for shower light
float lastRoomTemp = 0;             // save value for temperature room
float lastWaterTemp = 0;            // save value for temperature water
float lastShowerTemp = 0;           // save value for temperature shower
float lastPumpTemp = 0;             // save value for temperature pump area
float lastShowerHum = 0;            // save value for humidity shower
float lastPumpHum = 0;              // save value for humidity pump area


int RoomTempIx = -1;                // index of Water temp Dallas sensor on 1-wire
int WaterTempIx = -1;               // index of Water temp Dallas sensor on 1-wire

void before() { 
   // before comm library is started
   errcnt = 0;
   pingcnt = 0;

   // analog inputs  
   pinMode(SHOWER_LDR_PIN, INPUT); 
   pinMode(ROOM_LDR_PIN, INPUT); 
   pinMode(PUMP_ERR_LDR_PIN, INPUT); 
   pinMode(PUMP_PWR_LRD_PIN, INPUT); 
   pinMode(PUMP_MIC_PIN, INPUT); 
   pinMode(LEAK_PIN, INPUT); 
   pinMode(PUMP_CURRENT_PIN, INPUT); 
   analogReference(DEFAULT);
   analogRead(SHOWER_LDR_PIN); // at least one measurement to stabilize
 
   // relais outputs  
   pinMode(RELAIS1_PIN, OUTPUT); 
   digitalWrite(RELAIS1_PIN, LOW);
   pinMode(RELAIS2_PIN, OUTPUT); 
   digitalWrite(RELAIS2_PIN, LOW);
   pinMode(RELAIS3_PIN, OUTPUT); 
   digitalWrite(RELAIS3_PIN, LOW);
  
   // Startup up the OneWire library
   sensors.begin();
}

void setup() {
   // please note that setup happens before presentation(), so we cannot call send()
   sensors.setWaitForConversion(true);
   wait(500); // wait to settle DHT sensors
}

void presentation()  {
   // Send the sketch version information to the gateway and Controller
   sendSketchInfo("Basement Hub", "1.1");

   // Register all sensors to gw (they will be created as child devices)
  
   present(SHOWER_TEMP_ID, S_TEMP);
   present(SHOWER_HUM_ID, S_HUM);
   present(PUMP_TEMP_ID, S_TEMP);
   present(PUMP_HUM_ID, S_HUM);
   
   present(ROOM_LIGHT_ID, S_LIGHT_LEVEL);
   present(SHOWER_LIGHT_ID, S_LIGHT_LEVEL);

   present(PUMP_BITS_ID, S_DISTANCE); 
   present(PUMP_STATUS_ID, S_DISTANCE); 
   present(PUMP_RUN_ID, S_BINARY);

   present(LEAK_ID, S_WATER_LEAK);
   present(RELAIS1_ID, S_BINARY);
   present(RELAIS2_ID, S_BINARY);
   present(RELAIS3_ID, S_BINARY);
   present(PING_ID, S_DISTANCE); 

   numSensors = sensors.getDeviceCount();
   Serial.print("# temp sensors: ");
   Serial.println(numSensors);
   if (numSensors==2) {
      present(ROOM_TEMP_ID, S_TEMP);
      //present(ROOM_HUM_ID, S_HUM);  // dummy
      present(WATER_TEMP_ID, S_TEMP);
      //present(WATER_HUM_ID, S_HUM); // dummy
      RoomTempIx = 0;
      WaterTempIx = 1;
   }
}


void loop() {
   // we come here every 100 ms (defined in CHECK_FREQUENCY)
   unsigned long start_loop = millis();    // to allow adjusting wait time
   bool stat;
   float temperature;
   float humidity;
   unsigned int light;
  
   if (!initdone) {
      // tell the gateway we no longer have relais set
      send(relais1_msg.set(0)); 
      send(relais2_msg.set(0)); 
      send(relais3_msg.set(0)); 
   }

   // Handle Humidity and Temperature Shower
   if (dhtcnt>0) dhtcnt--;
   if (dhtcnt==0 || !initdone) {
      // Shower DHT
      temperature = showerdht.readTemperature();
      if (isnan(temperature)) {
          Serial.println("Failed reading showerdht temp");
      } else if (temperature != lastShowerTemp || !initdone) {
          lastShowerTemp = temperature;
          temperature += SHOWER_SENSOR_TEMP_OFFSET;
          send(showerTemp_msg.set(temperature, 1));
       }
       humidity = showerdht.readHumidity();
       if (isnan(humidity)) {
          Serial.println("Failed reading showerdht humidity");
       } else if (humidity != lastShowerHum || !initdone) {
          lastShowerHum = humidity;
          send(showerHum_msg.set(humidity, 1));
       }

       // Pump area DHT
       temperature = pumpdht.readTemperature();
       if (isnan(temperature)) {
          Serial.println("Failed reading pumpdht temp");
       } else if (temperature != lastPumpTemp || !initdone) {
          lastPumpTemp = temperature;
          temperature += PUMP_SENSOR_TEMP_OFFSET;
          send(pumpTemp_msg.set(temperature, 1));
       }
       humidity = pumpdht.readHumidity();
       if (isnan(humidity)) {
          Serial.println("Failed reading pumpdht humidity");
       } else if (humidity != lastPumpHum || !initdone) {
          lastPumpHum = humidity;
          send(pumpHum_msg.set(humidity, 1));
       }
       dhtcnt = MIN_SEND_FREQ;
   }


   // now handle light sensors
   if (lightcnt>0) lightcnt--;
   if (lightcnt==0 || !initdone) {
      light = (1023 - analogRead(ROOM_LDR_PIN)) / 10;
      if (light!=lastRoomlight || !initdone) {
         Serial.print("Room Light: "); Serial.println(light);
         if (send(roomLight_msg.set(light))) {
            lastRoomlight = light;
            lightcnt = MIN_SEND_FREQ;
         } else errcnt++;        
      }
      light = (1023 - analogRead(SHOWER_LDR_PIN)) / 10;
      if (light!=lastShowerlight || !initdone) {    
         Serial.print("Shower Light: "); Serial.println(light);
         if (send(showerLight_msg.set(light))) {
            lastShowerlight = light;
            lightcnt = MIN_SEND_FREQ;
         } else errcnt++;        
      }
   }

   // STILL TO DO
   if (!initdone) {
      send(pumpStatus_msg.set(0));
      send(pumpBits_msg.set(0));
      send(leak_msg.set(0));
   }
 
   
   // now handle Dallas temperature sensors (if they are connected)
   if (tempsendcnt>0) tempsendcnt--;
   if (tempsendcntmax>0) tempsendcntmax--;
   if (tempsendcnt == 0 || !initdone) {
      sensors.requestTemperatures();

      if (RoomTempIx>=0) {
      // Fetch and round temperature to one decimal
         temperature = static_cast<float>(static_cast<int>((getConfig().isMetric?sensors.getTempCByIndex(RoomTempIx):sensors.getTempFByIndex(RoomTempIx)) * 10.)) / 10.;
    
         // Only send data if temperature has changed and no error or we need to do it anyway
         if ((lastRoomTemp != temperature || tempsendcntmax==0) && temperature != -127.00 && temperature != 85.00) {
            // Send in the new temperature
            if (send(roomTemp_msg.set(temperature+ROOM_SENSOR_TEMP_OFFSET,1))) {
               // Save new temperature for next compare if we were able to send data
               lastRoomTemp=temperature;
               tempsendcnt = MIN_SEND_FREQ;  
            } else {
               tempsendcnt = MIN_SEND_FREQ_ERR;
               errcnt++;
            }
            // send(roomHum_msg.set(0.0,1));
         }
      }
      if (WaterTempIx>=0) {
      // Fetch and round temperature to one decimal
         temperature = static_cast<float>(static_cast<int>((getConfig().isMetric?sensors.getTempCByIndex(WaterTempIx):sensors.getTempFByIndex(WaterTempIx)) * 10.)) / 10.;
    
         // Only send data if temperature has changed and no error or we need to do it anyway
         if ((lastWaterTemp != temperature || tempsendcntmax==0) && temperature != -127.00 && temperature != 85.00) {
            // Send in the new temperature
            if (send(waterTemp_msg.set(temperature+WATER_SENSOR_TEMP_OFFSET,1))) {
               // Save new temperature for next compare if we were able to send data
               lastWaterTemp=temperature;
               tempsendcnt = MIN_SEND_FREQ;  
            } else {
               tempsendcnt = MIN_SEND_FREQ_ERR;
               errcnt++;
            }
            // send(waterHum_msg.set(99.9,1));
         }
      }
      tempsendcntmax = MAX_SEND_FREQ; 
   }

  if (pingsendcnt>0) pingsendcnt--;
  if (pingsendcnt==0 || !initdone) {
      pingcnt++;
      send(ping_msg.set(pingcnt));
      pingsendcnt = MIN_PINGSEND_FREQ;
  }

   if (errcnt>=MAXERRCNT) resetFunc(); //call reboot
   initdone = true;
   
   // ready with all. Now wait for a while
   unsigned long end_loop = millis();
   // Serial.print(end_loop-start_loop);
   if (end_loop-start_loop<=CHECK_FREQUENCY)
      wait(CHECK_FREQUENCY - (end_loop-start_loop));
}

// receive command from Domoticz gateway (only lrelais on off signal2)
void receive(const MyMessage &message) {
   bool val;
   if (message.type==V_STATUS && message.sensor==RELAIS1_ID) {
      Serial.print("Relais 1-");
      val = message.getBool();
      digitalWrite(RELAIS1_PIN, val);
      Serial.println(val);
   } 
   if (message.type==V_STATUS && message.sensor==RELAIS2_ID) {
      Serial.print("Relais 2-");
      val = message.getBool();
      digitalWrite(RELAIS2_PIN, val);
      Serial.println(val);
   } 
   if (message.type==V_STATUS && message.sensor==RELAIS3_ID) {
      Serial.print("Relais 3-");
      val = message.getBool();
      digitalWrite(RELAIS3_PIN, val);
      Serial.println(val);
   } 
}

void audioread() {
   cli();  // UDRE interrupt slows this way down on arduino1.0
   for (int i = 0 ; i < FHT_N ; i++) { // save 256 samples
      while(!(ADCSRA & 0x10)); // wait for adc to be ready
      ADCSRA = 0xf5; // restart adc
      byte m = ADCL; // fetch adc data
      byte j = ADCH;
      int k = (j << 8) | m; // form into an int
      k -= 0x0200; // form into a signed int
      k <<= 6; // form into a 16b signed int
      fht_input[i] = k; // put real data into bins
    }
    
    fht_window(); // window the data for better frequency response
    fht_reorder(); // reorder the data before doing the fht
    fht_run(); // process the data in the fht
    fht_mag_log(); // take the output of the fht
    sei();
    Serial.println("start");
    for (byte i = 0 ; i < FHT_N/2 ; i++) {
      Serial.println(fht_log_out[i]); // send out the data
    }
}

